<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js coal">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>2021-03-20 Don&#x27;t panic!() - wngr</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="My personal notes. Mostly about programming.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="../favicon.svg">
        
        
        <link rel="shortcut icon" href="../favicon.png">
        
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="../fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "coal";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('coal')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../hello_world.html">Hello, World!</a></li><li class="chapter-item expanded affix "><a href="../about.html">About</a></li><li class="spacer"></li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.</strong> Blog</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../blog/2021-08-31_Introduction-Wasm-Threads.html"><strong aria-hidden="true">1.1.</strong> 2021-08-31 Introduction to WebAssembly Threads in Rust</a></li><li class="chapter-item expanded "><a href="../blog/2021-04-06_Sniffing-into-Signal-Backups.html"><strong aria-hidden="true">1.2.</strong> 2021-04-06 Sniffing into Signal Backups</a></li><li class="chapter-item expanded "><a href="../blog/2021-03-24_Rust-Cross.html"><strong aria-hidden="true">1.3.</strong> 2021-03-24 Painless Cross-Compilation of Rust Crates</a></li><li class="chapter-item expanded "><a href="../blog/2021-03-20_Dont-Panic.html" class="active"><strong aria-hidden="true">1.4.</strong> 2021-03-20 Don't panic!()</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">wngr</h1>

                    <div class="right-buttons">
                        
                        
                        <a href="https://github.com/wngr/wngr.github.io/tree/main/src" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="dont-panic"><a class="header" href="#dont-panic">Dont <code>panic!()</code></a></h1>
<p>The general error handling story with Rust feels very ergonomic and more importantly very obvious and plausible to a
programmer.  There are exactly two kind of errors:</p>
<ol>
<li>Recoverable errors, represented by the <code>Result&lt;T,E&gt;</code> type, and</li>
<li>unrecoverable errors, where the program panics.</li>
</ol>
<p>This post is about the latter: What happens exactly if we call <code>panic!()</code> in a Rust program, which options are there to
modify and influence this behaviour, and what are the caveats? This write-up is non-exhaustive, but highlights the
noteworthy points that helped me understand it better. Platform specific nuances are not considered, if they are not
necessary to understand.</p>
<p>Panics are commonly used to enforce an invariant of a program, which must not be broken and is completely unexpected by
the application's logic. For further considerations when to use panics or not, see this
<a href="https://doc.rust-lang.org/book/ch09-03-to-panic-or-not-to-panic.html">section</a> in the Rust book.</p>
<p>Let's consider a simple panic<sup class="footnote-reference"><a href="#0">1</a></sup>:</p>
<pre><pre class="playground"><code class="language-rust should_panic edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>panic!(&quot;boom&quot;);
println!(&quot;Nobody prints me :-(&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>The argument passed to the <code>panic!</code> macro is printed, and further execution is stopped. In the following, we will trace
what just happened.</p>
<h3 id="the-panic-macro"><a class="header" href="#the-panic-macro">The <code>panic!</code> macro</a></h3>
<p>The <code>panic!</code> macro is defined in <a href="https://doc.rust-lang.org/src/std/macros.rs.html#12-18">std</a>:</p>
<pre><code class="language-rust no_run noplayground ignore">macro_rules! panic {
    () =&gt; ({ $crate::panic!(&quot;explicit panic&quot;) });
    ($msg:expr $(,)?) =&gt; ({ $crate::rt::begin_panic($msg) });
    ($fmt:expr, $($arg:tt)+) =&gt; ({
        $crate::rt::begin_panic_fmt(&amp;$crate::format_args!($fmt, $($arg)+))
    });
}
</code></pre>
<p>So it either accepts a string literal with formatting args (like <code>format!</code>), an object, or no argument at all (fallback
to a default string literal). The object needs to fulfill the <code>Any + Send</code> trait bounds to be able to call
<a href="https://github.com/rust-lang/rust/blob/507bff92fadf1f25a830da5065a5a87113345163/library/std/src/panicking.rs#L513-L521"><code>begin_panic</code></a>:</p>
<blockquote>
<p><strong>Update for Rust 1.51.0:</strong>
Starting with 1.51.0, the <code>panic!</code> macro only takes <code>String</code> or <code>&amp;str</code> payload. If you want to pass any object, you
should use <code>std::panic::panic_any</code> instead, which will directly call <code>begin_panic</code> (see below):</p>
</blockquote>
<pre><code class="language-rust no_run noplayground ignore">pub fn begin_panic&lt;M: Any + Send&gt;(msg: M) -&gt; ! {
    if cfg!(feature = &quot;panic_immediate_abort&quot;) {
        intrinsics::abort()
    }

    let loc = Location::caller();
    return crate::sys_common::backtrace::__rust_end_short_backtrace(move || {
        rust_panic_with_hook(&amp;mut PanicPayload::new(msg), None, loc)
    });
</code></pre>
<p>Interesting, with the <code>panic_immediate_abort</code> feature set, the program immediately aborts without any further actions.
This is not to be confused with the <code>panic = &quot;abort&quot;</code> setting in <code>Cargo.toml</code>, which sets the <code>panic_abort</code> runtime. This
is used in order to get really tiny binaries. You need to
<a href="https://github.com/rust-lang/rust/issues/54981#issuecomment-443369450">compile</a> Rust's std library yourself with said 
feature flag set in order to use it.</p>
<h3 id="panic-hook"><a class="header" href="#panic-hook">Panic hook</a></h3>
<p><code>rust_panic_with_hook</code> will do some checking for recursive panics (it will terminate immediately in this case), and
execute the panic hook, before dispatching to the panic runtime to unwind (or abort). Users can set a custom panic hook,
which is executed for every panic, with <code>std::panic::set_hook</code>. This is a global resource, so last writer wins.</p>
<pre><pre class="playground"><code class="language-rust should_panic edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>std::panic::set_hook(Box::new(|_panic_info| {
  println!(&quot;Hello Panic!&quot;);
}));
panic!();
<span class="boring">}
</span></code></pre></pre>
<p>The <code>PanicInfo</code> type propagates meta information of the panic (location, payload or message). Any custom set panic hooks
can be unset by <code>std::panic::take_hook()</code> which will leave Rust's default panic hook in place.</p>
<h3 id="panic-runtime"><a class="header" href="#panic-runtime">Panic runtime</a></h3>
<p>After control flow returned from the panic hook, a FFI function<sup class="footnote-reference"><a href="#1">2</a></sup> is called:</p>
<pre><code class="language-rust no_run noplayground ignore">fn __rust_start_panic(payload: *mut &amp;mut dyn BoxMeUp) -&gt; u32;
</code></pre>
<p>This is a native interface, because rustc will make sure that user chosen panic runtime is linked against after the
compilation step.</p>
<p>Rust provides two panic runtimes: <code>panic_abort</code> and <code>panic_unwind</code>. <code>panic_abort</code> just aborts the program (via a
platform specific syscall, e.g. <code>libc::abort()</code>) and can be enabled in <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[profile.dev]
panic = &quot;abort&quot;

[profile.release]
panic = &quot;abort&quot;
</code></pre>
<p>The default is
<a href="https://github.com/rust-lang/rust/blob/89882388d931d2e4d0d30c73fc1aa9c56f4df110/library/panic_unwind/src/lib.rs#L1-L12"><code>panic_unwind</code></a>,
which implements platform specific stack unwinding: In general, an unwinder walks the stack from top to bottom, where
for each frame a so-called &quot;personality routine&quot; is called (those are provided by this runtime). This routine determines
for the individual stack frame, which actions to take to handle an exception. If a handler frame has been found (so
basically a catch block), the cleanup phase begins, where for each stack frame a &quot;landing pad&quot; is generated, which runs
destructors, frees memory etc. Once the stack has been unwound, control is transferred to the handler frame. If no
handler frame was found, the process is terminated. This is not unique to Rust, but behaviour of the <a href="https://llvm.org/docs/ExceptionHandling.html#overview">LLVM
backend</a>.</p>
<h3 id="catching-a-panic"><a class="header" href="#catching-a-panic">Catching a panic</a></h3>
<p>With the <code>panic_unwind</code> runtime, a panic triggers the unwinding of the stack. After the stack has been unwound, and no
handler frame (catch block, see above) has been found, the process is terminated.  The Rust standard library provides a
mechanism to &quot;catch&quot; a panic after the stack has been unwound: <code>std::panic::catch_unwind</code>, which takes a closure that
might potentially panic, and returns a <code>Result&lt;T, Box&lt;dyn Any + Send + 'static&gt;&gt;</code>. This eventually ends up in the
compiler intrinsics, where LLVM instructions for a try-catch block are fabricated (for GNU, see
<a href="https://github.com/rust-lang/rust/blob/master/compiler/rustc_codegen_llvm/src/intrinsic.rs#L537-L542">here</a>). With
that, <code>std::panic::catch_unwind</code> is able to catch a panic, after the stack has been safely unwound.</p>
<p>But why even try to catch a panic at all, given that it's considered a unrecoverable error? There are a couple of
potential motivations: supervision of third party (library) code, robustness concerns (think safety critical systems),
or managing of thread pools (for example in async runtimes). The canonical example of this (one where the motivation of
Rust's creators is well visible) is <a href="https://doc.rust-lang.org/src/std/thread/mod.rs.html#473-475"><code>std::thread</code></a>: Any
panics encountered in a spawned thread are unwound, after which the (OS) thread exits. The <code>JoinHandle</code> returns from the
thread's <code>spawn</code> method will carry the panic, if any happened. <code>tokio::task::spawn</code> took a similar approach (sans the OS
thread exit, of course).</p>
<p><code>std::panic::resume_unwind</code> provides a way to trigger a panic without invoking the panic hook. If invoked with a panic
caught by <code>std::panic::catch_unwind</code>, the panic hook has been already executed for said panic, and the stack unwound.
The stack will be unwound again with <code>resume_unwind</code>, but this time without any catch blocks (if not nested with another
<code>catch_unwind</code>).</p>
<p>Note that all types passed into <code>catch_unwind</code> need to be
<a href="https://doc.rust-lang.org/std/panic/trait.UnwindSafe.html"><code>UnwindSafe</code></a>. When used only from within safe Rust code,
problematic is only shared mutable state, which could violate application level invariants. More considerations apply if
you interface with foreign code.</p>
<h3 id="reacting-to-panics-in-application-level-code"><a class="header" href="#reacting-to-panics-in-application-level-code">Reacting to panics in application level code</a></h3>
<p>Writing applications in Rust, I think it's advisable to stick to the recommendations of the Rust core team regarding
error handling<sup class="footnote-reference"><a href="#2">3</a></sup>. Panics should be used as a last resort for non-recoverable errors. The logical conclusion from that
is to always use the <code>panic_abort</code> runtime, so that any panic in any thread will bring down the whole process. However,
it's good to have some sort of shutdown procedure (close database connections, flush to disk, etc.) to orderly bring
down your application (if needed). This can be implemented by placing a custom panic hook with
<code>std::panic::set_hook</code><sup class="footnote-reference"><a href="#3">4</a></sup>. As long as the closure passed to the hook finishes all work synchronously, we can stick with
the <code>panic_abort</code> runtime; if we can only signal the shutdown to other threads and then yield, we obviously have to use
the <code>panic_unwind</code> runtime -- otherwise the program would immediately exit after the panic hook returns.</p>
<hr />
<div class="footnote-definition" id="0"><sup class="footnote-definition-label">1</sup>
<p>This is a runnable snippet, so you can click on the play button above.</p>
</div>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">2</sup>
<p>If you're curious about the type of <code>payload</code>, check out <a href="https://rustc-dev-guide.rust-lang.org/panic-implementation.html#std-implementation-of-panic">this
explanation</a>.</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">3</sup>
<p>The Rust Book has a very well written <a href="https://doc.rust-lang.org/book/ch09-00-error-handling.html">chapter</a> on error
handling, which is worth a read.</p>
</div>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">4</sup>
<p>For some inspiration to parse <code>PanicInfo</code>, check out the <a href="https://github.com/rust-lang/rust/blob/507bff92fadf1f25a830da5065a5a87113345163/library/std/src/panicking.rs#L180-L227">default hook in
std</a>.</p>
</div>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../blog/2021-03-24_Rust-Cross.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../blog/2021-03-24_Rust-Cross.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
